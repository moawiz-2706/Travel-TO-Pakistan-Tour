name: CI/CD to Docker Hub and Minikube

on:
  push:
    branches:
      - master

jobs:
  deploy:
    runs-on: self-hosted
    env:
      FRONTEND_IMAGE: "moawiz/travel-frontend:${{ github.sha }}"
      BACKEND_IMAGE: "moawiz/travel-backend:${{ github.sha }}"
      MINIKUBE_DRIVER: hyperv

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1
          clean: true
          submodules: false

      - name: Configure System Paths
        shell: powershell
        run: |
          $env:Path += ";C:\Program Files\Docker\Docker\resources\bin"
          $env:Path += ";C:\Program Files\Git\cmd"
          $env:Path += ";C:\kubectl"

      - name: Safe Environment Cleanup
        shell: powershell
        run: |
          # Graceful cleanup that handles missing clusters
          minikube delete --all --purge || true
          docker context rm minikube -f || true
          Remove-Item -Path "$HOME\.minikube" -Recurse -Force -ErrorAction SilentlyContinue
          Remove-Item -Path "$HOME\.docker\contexts" -Recurse -Force -ErrorAction SilentlyContinue

      - name: Configure Network Infrastructure
        shell: powershell
        run: |
          # Reset network configuration
          Get-NetFirewallRule -Name "Minikube*" | Remove-NetFirewallRule -ErrorAction SilentlyContinue
          New-NetFirewallRule -Name "MinikubeDocker" -DisplayName "Minikube Docker" `
            -Direction Inbound -Protocol TCP -LocalPort 2376 -Action Allow
          New-NetFirewallRule -Name "MinikubeAPI" -DisplayName "Minikube API" `
            -Direction Inbound -Protocol TCP -LocalPort 8443 -Action Allow

          # Configure Hyper-V virtual switch
          $switchName = "MinikubeSwitch"
          if (-not (Get-VMSwitch -Name $switchName -ErrorAction SilentlyContinue)) {
              New-VMSwitch -Name $switchName -SwitchType Internal
          }

      - name: Initialize Minikube Cluster
        shell: powershell
        run: |
          # Start cluster with enhanced configuration
          minikube start `
            --driver=$env:MINIKUBE_DRIVER `
            --cni=flannel `
            --memory=8192 `
            --cpus=4 `
            --disk-size=40g `
            --force `
            --wait=all `
            --wait-timeout=25m `
            --apiserver-ips=127.0.0.1 `
            --apiserver-name=localhost `
            --extra-config=kubelet.cgroup-driver=systemd `
            --embed-certs

          # Verify cluster health
          minikube status
          kubectl cluster-info
          kubectl get pods -A

      - name: Configure Docker Environment
        shell: powershell
        run: |
          # Get fresh cluster information
          $env:MINIKUBE_IP = minikube ip
          "MINIKUBE_IP=$env:MINIKUBE_IP" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8
          
          # Configure certificate paths
          $env:DOCKER_CERT_PATH = "$HOME\.minikube\certs"
          "DOCKER_CERT_PATH=$env:DOCKER_CERT_PATH" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8

          # Verify certificates exist
          if (-not (Test-Path "$env:DOCKER_CERT_PATH\ca.pem")) { throw "Missing CA certificate" }
          if (-not (Test-Path "$env:DOCKER_CERT_PATH\cert.pem")) { throw "Missing client certificate" }
          if (-not (Test-Path "$env:DOCKER_CERT_PATH\key.pem")) { throw "Missing client key" }

          # Configure Docker context
          docker context create minikube `
            --docker "host=tcp://$env:MINIKUBE_IP:2376,ca=$env:DOCKER_CERT_PATH/ca.pem,cert=$env:DOCKER_CERT_PATH/cert.pem,key=$env:DOCKER_CERT_PATH/key.pem"
          
          docker context use minikube
          Write-Output "Current Docker contexts:"
          docker context ls

      - name: Validate Docker Connection
        shell: powershell
        run: |
          $maxRetries = 5
          $retryCount = 0
          $success = $false

          while (-not $success -and $retryCount -lt $maxRetries) {
              try {
                  Write-Output "Testing Docker connection (attempt $($retryCount + 1))..."
                  
                  # Verify network connectivity
                  Test-NetConnection -ComputerName $env:MINIKUBE_IP -Port 2376
                  
                  # Test Docker functionality
                  docker info
                  docker run --rm hello-world
                  
                  $success = $true
              } catch {
                  $retryCount++
                  Write-Output "Connection failed, retrying in 15 seconds..."
                  Start-Sleep -Seconds 15
                  
                  # Refresh environment
                  $env:MINIKUBE_IP = minikube ip
                  docker context use minikube
              }
          }

          if (-not $success) {
              throw "Failed to establish Docker connection after $maxRetries attempts"
          }

      # Remaining deployment steps remain unchanged
      - name: Build & Push Frontend
        uses: docker/build-push-action@v5
        with:
          context: ./travel-to-pakistan/frontend
          tags: ${{ env.FRONTEND_IMAGE }}
          push: true
        env:
          DOCKER_HOST: tcp://${{ env.MINIKUBE_IP }}:2376
          DOCKER_TLS_VERIFY: 1
          DOCKER_CERT_PATH: ${{ env.HOME }}\.minikube\certs

      - name: Build & Push Backend
        uses: docker/build-push-action@v5
        with:
          context: ./travel-to-pakistan/backend
          tags: ${{ env.BACKEND_IMAGE }}
          push: true
        env:
          DOCKER_HOST: tcp://${{ env.MINIKUBE_IP }}:2376
          DOCKER_TLS_VERIFY: 1
          DOCKER_CERT_PATH: ${{ env.HOME }}\.minikube\certs

      - name: Deploy Kubernetes Stack
        shell: powershell
        run: |
          kubectl create namespace travel-app --dry-run=client -o yaml | kubectl apply -f -

          kubectl create secret generic app-secrets -n travel-app `
            --from-literal=JWT_SECRET="${{ secrets.JWT_SECRET }}" `
            --from-literal=GOOGLE_CLIENT_ID="${{ secrets.GOOGLE_CLIENT_ID }}" `
            --from-literal=GOOGLE_CLIENT_SECRET="${{ secrets.GOOGLE_CLIENT_SECRET }}" `
            --dry-run=client -o yaml | kubectl apply -f -

          kubectl apply -f ./travel-to-pakistan/mongodb/ -n travel-app
          kubectl wait --for=condition=ready pod -l app=mongodb -n travel-app --timeout=300s
          kubectl apply -f ./travel-to-pakistan/backend/ -n travel-app
          kubectl apply -f ./travel-to-pakistan/frontend/ -n travel-app

          kubectl expose deployment frontend -n travel-app --type=NodePort --port=80
          kubectl expose deployment backend -n travel-app --type=NodePort --port=3000

          minikube service list -n travel-app

      - name: Smoke Tests
        shell: powershell
        run: |
          $frontendUrl = minikube service frontend -n travel-app --url
          $backendUrl = minikube service backend -n travel-app --url

          function Test-Endpoint {
              param($url)
              $retryCount = 0
              while ($retryCount -lt 5) {
                  try {
                      $response = Invoke-WebRequest $url -UseBasicParsing -TimeoutSec 30
                      if ($response.StatusCode -eq 200) { return $true }
                  } catch { }
                  $retryCount++
                  Start-Sleep -Seconds 15
              }
              return $false
          }

          if (-not (Test-Endpoint "$frontendUrl/health")) { throw "Frontend health check failed" }
          if (-not (Test-Endpoint "$backendUrl/api/health")) { throw "Backend health check failed" }